``` xml
<mapper namespace="com.example.demo.app.shop.dal.UserMapper"
<select id="checkPass' resultType="com.example.demo.app.shop.entity.User
select 1 from user where user_pass=${pass} and user_id=${id}
</select>


<!-- mybatis中$变量直接替换的，黑客可以进行SQL注入 -->
```


注入案例:
select 1 from user where user_pass='' OR '1'='1' and user_id=1 OR 1=1


```xml
<mapper namespace="com.example.demo.app.shop.dal.UserMapper">
  <select id="checkPass" resultType="com.example.demo.app.shop.entity.User">
    select 1 from user where user_pass=#{pass} and user_id=#{id}
  </select>
</mapper>

<!-- 正确做法：使用#{}进行预编译处理 -->
```


``` java
@RequestMapping("/content/get")
public String contentGet(@RequestParam(value = "filename") String filename) throws IOException {
    Path p = Paths.get("/var/web", filename);
    byte[] bs = Files.readAllBytes(p);
    return new String(bs, StandardCharsets.UTF_8);
}
```

严重的路径遍历漏洞（Path Traversal Vulnerability）

``` shell
filename=../../etc/passwd        # Unix系统
filename=..\..\windows\win.ini  # Windows系统
```


使用normalize()+ 路径前缀验证
``` java
@RequestMapping("/content/get")
public String contentGet(@RequestParam String filename) throws IOException {
    Path baseDir = Paths.get("/var/web").normalize();
    Path userPath = Paths.get("/var/web", filename).normalize();
    
    // 关键校验：确保解析后的路径在允许的目录内
    if (!userPath.startsWith(baseDir)) {
        throw new IllegalArgumentException("非法文件路径");
    }
    
    byte[] content = Files.readAllBytes(userPath);
    return new String(content, StandardCharsets.UTF_8);
}
```




``` java
public Document loadXml(String filename) throws ParserConfigurationException, SAXException, IOException {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = factory.newDocumentBuilder();
    try (java.io.InputStream inputStream = new java.io.FileInputStream(filename)) {
        return builder.parse(inputStream);
    }
}
```

XML External Entity
``` xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

解决方案: 禁用外部实体解析

``` java
public Document loadXml(String filename) throws ParserConfigurationException, SAXException, IOException {
// 在XML解析前配置安全特性
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
// 禁用DOCTYPE声明（防止DTD注入）
    factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
// 禁用外部实体解析
    factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
    factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
    factory.setXIncludeAware(false);
    factory.setExpandEntityReferences(false);

    DocumentBuilder builder = factory.newDocumentBuilder();
    try (java.io.InputStream inputStream = new java.io.FileInputStream(filename)) {
        return builder.parse(inputStream);
    }
}
```